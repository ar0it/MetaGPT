from pydantic import BaseModel, Field
from typing import Optional
from ome_types._autogenerated.ome_2016_06 import OME, StructuredAnnotations, XMLAnnotation
import instructor
from openai import OpenAI
import time
import sys
import importlib
import ast
import numpy as np

from metagpt.predictors.predictor_template import PredictorTemplate
from metagpt.predictors.predictor_simple_annotator import PredictorSimpleAnnotation
import metagpt.utils.utils as utils

class PredictorNetworkAnnotation(PredictorTemplate):
    """
    This predictor approach uses two assistants, one for splitting the raw metadata into already contained and new metadata,
    and one for predicting the structured annotations from the new metadata.
    """
    
    def __init__(self, raw_meta: str) -> None:
        super().__init__()
        self.raw_metadata = raw_meta
        self.full_message = "The raw data is: \n" + str(self.raw_metadata)

        self.sep_prompt = """
        You are part of a toolchain designed to predict metadata for the OME model, specifically the structured annotations part.
        You will be interacting with other toolchain components, therefore asking questions or providing any human-readable output is not necessary.
        Your task will be to take raw metadata in the form of key-value pairs and sort out the one that do not have an appropriate place in the ome datamodel,
        but instead need to be added as structured annotation. For that purpose you have access to the OME schema via vectorized embeddings.
        Furthermore to improve the consistency of the ouput, you have acess to the OutputTool which will structure the output key value pairs appropriately.
        ALWAYS USE THE TOOL TO PRODUCE RELIABLE OUTPUTS.
        If you understood all of this, and will follow the instructions, answer with "." and wait for the first metadata to be provided.
        """
        self.pred_prompt = """
        You are part of a toolchain designed to predict metadata for the OME model, specifically the structured annotations part.
        You will be interacting with other toolchain components, therefore asking questions or providing any human-readable output is not necessary.
        Your task will be to take raw metadata in the form of a dictionary of key-value pairs and put them into the XMLAnnotation section of the OME model.
        Importantly, try to structure the metadata in a hierarchical manner, grouping related properties together.
        Try to understnad exactly how the metadata properties are related to each other and make sense of them.
        Try to figure out a good structure by looking at the raw metadata in a holistic manner.
        Furthermore the function StructuredAnnotations is provided to help you structure the metadata.
        Always use the tool to get reliable results.
        Fill out the StructuredAnnotations object with the metadata you think is appropriate, in the appopriate structure.
        Since this is a hard problem, I will need you to think step by step and use chain of thought.
        Here is the structure of how to approach the problem step by step:
        1. Look at the raw metadata, which properties can be grouped together or are related?
        2. Figure out if you can groupt these properties in a hierarchical manner, do they cluster together?
        3. Come to a conclusion how you want to structure the metadata.
        4. Call the StructuredAnnotations function with the annotations as JSON string.
        Remember to solve this problem step by step and use chain of thought to solve it.
        Again, you are not interacting with a human but are part of a chain of tools that are supposed to solve this problem.
        Under no circumstances can you ask questions.
        You will have to decide on your own. ONLY EVER RESPOND WITH THE JSON FUNCTION CALL.
        Use the provided function to solve the task. YOU NEED TO CALL THE FUNCTION TO SOLVE THE TASK. The chat response will be ignored.
        If you understood all of this, and will follow the instructions, answer with "." and wait for the first metadata to be provided.
        """

    
    def predict(self) -> StructuredAnnotations:
        """
        TODO: Add docstring
        """
        self.init_sep_thread()
        self.init_vector_store()
        self.init_sep_assistant()   

        self.init_sep_run()
        try:
            self.sep_response = self.sep_run.required_action.submit_tool_outputs.tool_calls[0].function.arguments

        except:
            if self.attempts < 1:
                self.attempts += 1
                return self.predict()
            else:
                return None, None, self.attempts
        
        cost_sep = self.get_cost(run=self.sep_run)

        self.pred_response, pre_cost, attempts = PredictorSimpleAnnotation("Here is the preselected raw metadata \n" + self.sep_response).predict()
        self.clean_assistants()
        return self.pred_response, 0, np.mean([attempts, self.attempts])
    
    def init_sep_run(self):
        self.sep_run = self.client.beta.threads.runs.create(
            thread_id=self.sep_thread.id,
            assistant_id=self.sep_assistant.id,
            tool_choice="required",
            temperature=0.0,
            )
        
        end_status = ["complete", "requires_action", "failed"]
        while self.sep_run.status not in end_status:
            print(self.sep_run.status)
            time.sleep(5)
            self.sep_run = self.client.beta.threads.runs.retrieve(
                thread_id=self.sep_thread.id,
                run_id=self.sep_run.id
                )
            
        print(self.sep_run.status)

    def init_sep_assistant(self):
        self.sep_assistant = self.client.beta.assistants.create(
            name="OME XML Seperator",
            description="An assistant to seperate raw metadata into already contained and new metadata. Use the knowledge base of the omexml schema, to make the best decsion",
            instructions=self.sep_prompt,
            model="gpt-4o",
            tools=[{"type": "file_search"}, utils.openai_schema(self.OutputTool)],
            tool_resources={"file_search": {"vector_store_ids": [self.vector_store.id]}}
        )
        self.assistants.append(self.sep_assistant)

    
    def init_vector_store(self):
        self.vector_store = self.client.beta.vector_stores.create(
            name="OME XML Schema",
        )
        file_paths = ["/home/aaron/Documents/Projects/MetaGPT/in/schema/ome_xsd.txt"]
        file_streams = [open(path, "rb") for path in file_paths]

        file_batch = self.client.beta.vector_stores.file_batches.upload_and_poll(
            vector_store_id=self.vector_store.id, files=file_streams
            )
        self.vector_stores.append(self.vector_store)
        
    def init_sep_thread(self):
        self.sep_thread = self.client.beta.threads.create(messages=[{"role": "user", "content": self.sep_prompt},
                                                                {"role": "assistant", "content": "."},
                                                                {"role": "user", "content": self.full_message}])
        self.threads.append(self.sep_thread)
    

    class OutputTool(BaseModel):
        """
        This tool automatically formats and structures the metadata in the appropriate way.
        """
        prop: Optional[list[str]] = Field(default_factory=list, description="A list of properties which are to be put into the structured annotations.")