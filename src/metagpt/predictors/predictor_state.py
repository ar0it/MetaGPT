"""
This module contains the PredictorState class, which is responsible for
predicting and updating OME metadata using JSON patches and OpenAI's language model.
"""

import ast
import json
import time
from typing import Optional, List, Literal, Any, Union, Dict

from pydantic import BaseModel, Field
from openai import OpenAI
from ome_types import from_xml, to_xml
from ome_types._autogenerated.ome_2016_06 import OME

from metagpt.predictors.predictor_template import PredictorTemplate
import metagpt.utils.utils as utils

class AddReplaceTestOperation(BaseModel):
    """Model for Add, Replace, and Test operations in JSON Patch."""
    op: Literal["add", "replace", "test"]
    path: str = Field(..., description="A JSON Pointer path.")
    value: Any = Field(..., description="The value to add, replace or test.")

class RemoveOperation(BaseModel):
    """Model for Remove operation in JSON Patch."""
    op: Literal["remove"]
    path: str = Field(..., description="A JSON Pointer path.")

class MoveCopyOperation(BaseModel):
    """Model for Move and Copy operations in JSON Patch."""
    op: Literal["move", "copy"]
    path: str = Field(..., description="A JSON Pointer path.")
    from_: str = Field(..., alias="from", description="A JSON Pointer path pointing to the location to move/copy from.")

class JsonPatch(BaseModel):
    """Model for a complete JSON Patch."""
    root: List[Union[AddReplaceTestOperation, RemoveOperation, MoveCopyOperation]]

    class Config:
        title = "JSON schema for JSONPatch files"
        json_schema_extra = {
            "$schema": "http://json-schema.org/draft-04/schema#",
            "id": "https://json.schemastore.org/json-patch.json",
        }

class update_json_state(BaseModel):
    """Model for updating the state of the predictor from a list of JSON patches."""
    json_patches: Optional[List[JsonPatch]] = Field(default_factory=list, description="List of JSON patches to apply.")

class PredictorState(PredictorTemplate):
    """
    A predictor class that generates and applies JSON patches to update OME metadata
    using OpenAI's language model.
    """

    def __init__(self, raw_meta: str, state: BaseModel = None) -> None:
        """
        Initialize the PredictorState.

        Args:
            raw_meta (str): The raw metadata to process.
            state (BaseModel, optional): The initial state. Defaults to OME().
        """
        super().__init__()
        self.state = state or OME()
        self.json_patches = "No Patch has been generated yet."
        self.last_error = "No error was thrown yet."
        self.raw_metadata = raw_meta
        self.query = self._generate_query()
        self.current_state_documentation = self._generate_state_documentation()
        self.current_state_message = self._generate_state_message()
        self.json_patch_examples = self._load_json_patch_examples()
        self.ome_types_doc = self._load_ome_types_doc()
        self.prompt = self._generate_prompt()
        self.description = self._generate_description()
        self.file_paths = [self._save_ome_types_schema()]

    def _generate_query(self) -> str:
        return f"""
        The raw data is: \n" {str(self.raw_metadata)} \n please predict the metadata for the {type(self.state)} object.
        In a previous attempt the following json patches were generated: {self.json_patches} and the following error was
        returned: {self.last_error}. Try to correct the mistake and generate a valid json patch.
        """

    def _generate_state_documentation(self) -> str:
        return f"""
        Here is the schema to the respective state object, this is what you are supposed to predict:
        {utils.browse_schema(self.state.__class__, max_depth=1)}
        """

    def _generate_state_message(self) -> str:
        return f"The current state is: \n{self.state.model_dump_json()}\nYou can think of this as your starting point from which you are supposed to expand."

    def _load_json_patch_examples(self) -> str:
        # Load JSON patch examples from a file or define them here
        return """
        # Example JSON patch operations
        [
            {"op": "add", "path": "/images/0/description", "value": "A new description"},
            {"op": "remove", "path": "/images/0/pixels/channels/2"},
            {"op": "replace", "path": "/images/0/name", "value": "Updated Image Name"}
        ]
        """

    def _load_ome_types_doc(self) -> str:
        # Load OME types documentation from a file or define it here
        return """
        # OME Types Documentation
        ome_types is useful for parsing the OME-XML format into Python objects for interactive or programmatic access in python.
        It can also take these Python objects and turn them back into OME-XML.
        """

    def _generate_prompt(self) -> str:
        return f"""
        To solve the task of generating json patches from raw unstructured metadata,
        you are given several tools etc.
        First of all you are updating a persistent state object, this helps you to
        update the state step by step. To do so you are provided the update_json_state
        function, which takes a list of json patches as input and updates the state object.
        Importantly you are not always given the OME state object, but only a part of it.
        This means you need to generate the json patches for the provided part of the schema.
        The paths in the patches are therefore relative to the provided state object.
        Make sure you don't add the full path to the state object, but only the path to the provided part of the schema.
        Also remember, that json patches are python code and therefore need to follow
        its syntax. For example boolean values are written as uppercase True or False.
        The json patches are structured as follows:
        {self.json_patch_examples}
        The ome_types OME object is structured slightly different from the default xml schema.
        Namely the properties are written lower case with underscores instead of camel case.
        Further Elements nodes such as image, pixels, channel etc. are collected as list of objects.
        Such as images, pixels, channels etc. in practice the element nodes therefore look as follows:
        images=[image1, image2, ...] furthermore properties such as the id and the top lvl attributes of the OME object such as Namespace, SchemaLocation etc.
        are generated automatically by the ome_types library. DO NOT ADD OR CHANGE PROPERTIES SUCH AS THE ID. THESE ARE GENERATED AUTOMATICALLY.
        You need to remember this when generating the json patches.
        You can access specific elements in the respective lists by calling its index in the path.
        For example:
        /images/0/pixels/size_x
        would access the size_x property of the pixels object of the first image in the images list.
        To give you some additional information on how the ome_types library works, here is a short documentation:
        {self.ome_types_doc}
        Since the task is quite difficult I need you to work step by step and use chain of thought.
        Furthermore the task might be provided to you in multiple steps, which means you are only provided part of the schema (such as the subnode pixels).
        In that case you only need to generate the json patches for the provided part of the schema.
        Because of this pay extra attention to the state provided, and only generate the json patches for the provided part of the schema.
        For example if you are only provided the pixels state a patch to create the pixel could look like this:
        {'{}'}
        Here is a structure of how to approach the problem step by step:
        1. look at the schema, what properties are there, which properties are required to generate the property in question?
        2. Look at the raw metadata, which properties could be related to the property in question?
        3. If the needed properties are not in the raw metadata, skip the property and exit without generating a patch.
        4. If the needed properties are in the raw metadata, generate a minimal patch, that creates the property in question.
        Don't try to generate a patch that includes all properties at once, but work step by step.
        This way the automatic validation tool can give you feedback on each step.
        5. After each successful patch, the state will be updated and the result will be provided to you for reference.
        6. If the patch was not successful, the state will not be updated and you will be asked to retry.
        You will also be provided with the error message that was generated.
        Carefully study the error message and try to understand what went wrong, before attempting to retry.
        If you understood all of this, and will follow the instructions, answer with "." and wait for the first metadata to be provided.
        """

    def _generate_description(self) -> str:
        return """
        You are OMEGPT, a tool designed to predict metadata for the OME model.
        More specifically you are supposed to generate json patches that will be
        used to update the ome_types OME data object.
        To solve the task you are given a set of key value pairs that represent
        raw unstructured metadata, which does not yet follow the ome schema.
        Your task is to figure out what the metadata could mean in the context
        of the OME schema.
        """

    def _save_ome_types_schema(self) -> str:
        ome_types_schema_path = "/home/aaron/Documents/Projects/MetaGPT/in/schema/ome_types_schema.json"
        with open(ome_types_schema_path, "w") as f:
            json.dump(OME.model_json_schema(), f)
        return ome_types_schema_path

    def predict(self, indent: Optional[int] = 0) -> tuple[Optional[str], float, int]:
        """
        Predict OME metadata and apply JSON patches to update the state.

        Args:
            indent (Optional[int]): Indentation for logging. Defaults to 0.

        Returns:
            tuple[Optional[str], float, int]: The updated OME XML, cost, and number of attempts.
        """
        print(indent * "  " + f"Predicting for {self.name}, attempt: {self.attempts}")
        print(type(self.state))
        self.message = self.current_state_message + self.current_state_documentation + self.query
        self.init_thread()
        self.init_vector_store()
        self.init_assistant()   
        self.init_run()
        response = None

        try:
            self.add_attempts()
            function_call = self.run.required_action.submit_tool_outputs.tool_calls[0]
            self.out_tokens += utils.num_tokens_from_string(function_call.function.arguments)
            if isinstance(function_call.function.arguments, str):
                response = ast.literal_eval(function_call.function.arguments)
            response = response['json_patches']
            self.json_patches = response
            for patch in response:
                self.state = utils.update_state(self.state, [patch])
            if self.state.__class__.__name__.startswith("Maybe"):
                self.state = getattr(self.state, self.model.__name__)
            response = to_xml(self.state)  

        except Exception as e:
            print(f"There was an exception in the {self.name}: {e}")
            print(response)
            self.last_error = str(e)
            if self.attempts < self.max_attempts:
                print(f"Retrying {self.name}...")
                self.clean_assistants()
                return self.predict(indent)
            else:
                response = None
                print(f"Failed {self.name} after {self.attempts} attempts.")
        
        self.clean_assistants()
        return response, self.get_cost(), self.attempts

    def init_run(self) -> None:
        """Initialize and monitor the run of the assistant."""
        self.run = self.client.beta.threads.runs.create(
            thread_id=self.thread.id,
            assistant_id=self.assistant.id,
            tool_choice={"type": "function", "function": {"name": "update_json_state"}},
            temperature=self.temperature,
        )
        
        end_status = ["completed", "requires_action", "failed"]
        while self.run.status not in end_status and self.run_iter < self.max_iter:
            self.run_iter += 1
            print(self.run.status)
            time.sleep(5)
            self.run = self.client.beta.threads.runs.retrieve(
                thread_id=self.thread.id,
                run_id=self.run.id
            )
            
        print(self.run.status)
        
    def init_assistant(self) -> None:
        """Initialize the OpenAI assistant."""
        self.assistant = self.client.beta.assistants.create(
            name="OMEGPT",
            description=self.description,
            instructions=self.prompt,
            model=self.model,
            tools=[{"type": "file_search"},
                   utils.openai_schema(update_json_state)],
            tool_resources={"file_search": {"vector_store_ids": [self.vector_store.id]}}
        )
        self.assistants.append(self.assistant)