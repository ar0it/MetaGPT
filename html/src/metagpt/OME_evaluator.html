<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>src.metagpt.OME_evaluator API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.metagpt.OME_evaluator</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.metagpt.OME_evaluator.OMEEvaluator"><code class="flex name class">
<span>class <span class="ident">OMEEvaluator</span></span>
<span>(</span><span>schema: str = None, experiment: <a title="src.metagpt.DataClasses.Experiment" href="DataClasses.html#src.metagpt.DataClasses.Experiment">Experiment</a> = None, out_path: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>This class evaluates the performance of a OME XML generation model by calculating the edit distance between the
ground truth and the prediction. <a href="https://github.com/timtadh/zhang-shasha">https://github.com/timtadh/zhang-shasha</a></p>
<p>:param path_to_raw_metadata: path to the raw metadata file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OMEEvaluator:
    &#34;&#34;&#34;
    This class evaluates the performance of a OME XML generation model by calculating the edit distance between the
    ground truth and the prediction. https://github.com/timtadh/zhang-shasha
    &#34;&#34;&#34;

    def __init__(self,
                 schema: str = None,
                 experiment: Experiment = None,
                 out_path: str = None):
        &#34;&#34;&#34;
        :param path_to_raw_metadata: path to the raw metadata file
        &#34;&#34;&#34;
        self.all_paths = None
        self.gt_graph = None
        #self.predicted = [self.string_to_ome_xml(x.metadata_str) for x in experiment.samples.values()]
        self.pred_graph = None
        self.out_path: str = out_path
        self.edit_score = []
        self.experiment = experiment
        self.plot_dict = {}
        self.qual_color_palette = sns.color_palette(&#34;husl&#34;, 8)
        self.palette0 = sns.palettes._ColorPalette(sns.color_palette(&#34;Paired&#34;)[0::2])
        self.palette1 = sns.palettes._ColorPalette(sns.color_palette(&#34;Paired&#34;)[1::2])



    def element_to_pygram(self, element: ET.Element):
        &#34;&#34;&#34;
        Convert an xml element to a pygram tree.
        &#34;&#34;&#34;
        node = tree.Node(element.tag)
        for child in element:
            node.addkid(self.element_to_pygram(child))
        return node
    

    def zss_edit_distance(self, xml_a: ET.Element, xml_b: ET.Element):
        &#34;&#34;&#34;
        Calculate the edit distance between two xml trees on word level.
        Here an outline of the algorithm:
        1. Get the paths of the xml trees.
        2. Align the paths such that the distance between the paths is minimized.
        3. Calculate the word level edit distance between the paths.
        &#34;&#34;&#34;
        self.pred_graph = self.get_graph(xml_a)
        self.gt_graph = self.get_graph(xml_b)
        return simple_distance(self.gt_graph, self.pred_graph)
    

    def pygram_edit_distance(self, xml_a: ET.Element, xml_b: ET.Element):
        &#34;&#34;&#34;
        Calculate the edit distance between two xml trees on word level.
        Here an outline of the algorithm:
        &#34;&#34;&#34;
        profile1 = Profile(self.element_to_pygram(xml_a), 2, 3)
        profile2 = Profile(self.element_to_pygram(xml_b), 2, 3)
        return profile1.edit_distance(profile2)
    

    @deprecated()
    def word_edit_distance(self, aligned_paths) -&gt; int:
        &#34;&#34;&#34;
        Calculate the word level edit distance between two sets of paths.
        aligned_paths: list of tuples of aligned paths
        &#34;&#34;&#34;
        edit_distance = 0
        for path_a, path_b in aligned_paths:
            # set the number of iterations to the length of the longest path
            iterations = len(path_a) if len(path_a) &gt; len(path_b) else len(path_b)
            distance = 0
            for i in range(iterations):
                node_b = path_b[i] if len(path_b) &gt; i else None
                node_a = path_a[i] if len(path_a) &gt; i else None
                if node_a != node_b:
                    distance += 1
            edit_distance += distance
        return edit_distance
    

    @deprecated()
    def align_paths(self, paths_a, paths_b):
        &#34;&#34;&#34;
        Align the paths such that the sum of distances between the paths is minimized.
        paths_a: set of paths
        paths_b: set of paths
        :return: list of tuples of aligned paths
        &#34;&#34;&#34;
        print(&#34;- - - Aligning paths - - -&#34;)
        # Assuming A and B are your lists and f is your function

        # Create the matrix
        matrix = [[self.align_sequences_score(a, b) for b in paths_b] for a in paths_a]
        print(&#34;matrix&#34;, [print(x, &#34;\n&#34;) for x in matrix])

        # score, alignment_a, alignment_b = self.align_sequences(paths_a, paths_b, cost=self.align_sequences_score)
        return 1, 1, 1

    @deprecated()
    def align_sequences_score(self, s1, s2, cost=lambda a, b: a != b):
        &#34;&#34;&#34;
        returns only the score for the alignment
        :param s1:
        :param s2:
        :param cost:
        :return:
        &#34;&#34;&#34;
        score, alignment_a, alignment_b = self.align_sequences(s1, s2, cost=lambda a, b: a != b)
        return score

    @deprecated()
    def align_sequences(self, s1, s2, cost=lambda a, b: a != b):
        print(&#34;- - - Aligning sequences - - -&#34;)
        m, n = len(s1), len(s2)
        # Create a matrix to store the cost of edits
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        dp = np.zeros((m + 1, n + 1))

        # Initialize the matrix with the cost of deletions and insertions
        for i in range(m + 1):
            dp[i][0] = i * +1
        for j in range(n + 1):
            dp[0][j] = j * +1

        # Fill the matrix based on the cost of substitution, insertion, and deletion
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if s1[i - 1] == s2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1]  # No cost if characters are the same
                else:
                    dp[i][j] = min(dp[i - 1][j - 1] + cost(s1[i - 1], s2[j - 1]),  # Substitution
                                   dp[i - 1][j] + cost(s1[i - 1], s2[j - 1]),  # Deletion
                                   dp[i][j - 1] + cost(s1[i - 1], s2[j - 1]),  # Insertion
                                   )
        # Reconstruct the alignment
        alignment_a, alignment_b = [], []
        i, j = m, n
        while i &gt; 0 and j &gt; 0:
            if s1[i - 1] == s2[j - 1]:
                alignment_a = [s1[i - 1]] + alignment_a
                alignment_b = [s2[j - 1]] + alignment_b
                i -= 1
                j -= 1
            elif dp[i][j] == dp[i - 1][j - 1] + cost(s1[i - 1], s2[j - 1]):  # substitution
                alignment_a = [s1[i - 1]] + alignment_a
                alignment_b = [s2[j - 1]] + alignment_b
                i -= 1
                j -= 1
            elif dp[i][j] == dp[i - 1][j] + cost(s1[i - 1], s2[j - 1]):  # deletion
                alignment_a = [s1[i - 1]] + alignment_a
                alignment_b = [[&#34;-&#34;]] + alignment_b
                i -= 1
            else:  # dp[i][j] == dp[i][j - 1] + cost_insertion  # insertion
                alignment_a = [[&#34;-&#34;]] + alignment_a
                alignment_b = [s2[j - 1]] + alignment_b
                j -= 1

        # Handle the remaining characters in s1 or s2
        while i &gt; 0:
            alignment_a = [s1[i - 1]] + alignment_a
            alignment_b = [[[&#34;-&#34;] * len(s1[j - 1])]] + alignment_b
            i -= 1
        while j &gt; 0:
            alignment_a = [[[&#34;-&#34;] * len(s2[j - 1])]] + alignment_a
            alignment_b = [s2[j - 1]] + alignment_b
            j -= 1
        print(dp)
        return dp[-1][-1], alignment_a, alignment_b
    

    def get_paths(self, xml_root: ET.Element, path: str = &#39;&#39;) -&gt; set:
        &#34;&#34;&#34;
        Helper function to get all paths in an XML tree.
        :return: set of paths
        &#34;&#34;&#34;
        paths = set()
        for child in xml_root:
            new_path = path + &#39;/&#39; + child.tag.split(&#39;}&#39;)[1]
            if child.attrib:
                for key in child.attrib.keys():
                    paths.add(new_path + &#39;/&#39; + key + &#39;=&#39; + child.attrib[key])
                    paths.update(self.get_paths(child, new_path))
            else:
                paths.add(new_path)
                paths.update(self.get_paths(child, new_path))
        return paths
    

    def get_graph(self, xml_root: ET.Element, root=None):
        &#34;&#34;&#34;
        Helper function to get the graph representation of an XML tree.
        &#34;&#34;&#34;
        if root is None:
            root = Node(&#34;OME&#34;)
            if xml_root.attrib:
                for key in xml_root.attrib.keys():
                    root.addkid(Node(key + &#39;=&#39; + xml_root.attrib[key]))

        for child in xml_root:
            new_node = Node(child.tag.split(&#39;}&#39;)[1])
            root.addkid(new_node)
            if child.attrib:
                for key in child.attrib.keys():
                    new_node.addkid(Node(key + &#39;=&#39; + child.attrib[key]))
            self.get_graph(child, new_node)
        return root
    

    def path_difference(self, xml_a: ET.Element, xml_b: ET.Element):
        &#34;&#34;&#34;
        Calculates the length of the difference between the path sets in two xml trees.
        &#34;&#34;&#34;
        paths_a = self.get_paths(xml_a)
        paths_b = self.get_paths(xml_b)
        print(&#34;path difference: &#34;, paths_a)
        return len(paths_a.symmetric_difference(paths_b))
    

    def read_ome_xml(self, path: str):
        &#34;&#34;&#34;
        This method reads the ome xml file and returns the root element.
        &#34;&#34;&#34;
        tree = ET.parse(path)
        root = tree.getroot()
        print(&#34;root&#34;, tree)
        return root

    def string_to_ome_xml(self, string):
        &#34;&#34;&#34;
        This method reads the ome xml string and returns the root element.
        &#34;&#34;&#34;
        root = ET.fromstring(string)
        return root

    def flatten(self, container):
        for i in container:
            if isinstance(i, (list, tuple, set)):
                yield from self.flatten(i)
            else:
                yield i
    

    def report(self):
        &#34;&#34;&#34;
        Write evaluation report to file.
        &#34;&#34;&#34;
        with open(f&#34;{self.out_path}/reports/report_test.md&#34;, &#34;w&#34;) as f:
            f.write(&#34;# Evaluation Report\n&#34;)
            f.write(&#34;## File content\n&#34;)
            f.write(f&#34;### File Ground Truth: \n&#34;)
            # create a dataframe with the paths
            df_paths = self.path_df()
            print(df_paths)
            # create a dataframe with the samples properties
            df_sample = self.sample_df(df_paths)
            print(df_sample)
            # create the plots
            self.method_edit_distance_plt(df_sample)
            self.n_paths_method_plt(df_sample)
            self.format_method_plot(df_sample)
            self.paths_annotation_stacked_plt(df_sample)
            self.method_attempts_plot(df_sample)
            self.format_counts_plt(df_sample)
            self.paths_annotation_stacked_relative_plt(df_sample)
            self.attempts_paths_plt(df_sample)
            # add the plots to the report
            f.write(&#34;## Path Comparison\n&#34;)
            for k, v in self.plot_dict.items():
                f.write(f&#34;![{k}]({v})\n&#34;)


    def sample_df(
            self,
            df_paths: pd.DataFrame = None,
    ):
        &#34;&#34;&#34;
        This function creates a df with samples as Index and properties as Columns.
        TODO: Add docstring
        &#34;&#34;&#34;
        properties = [&#34;Method&#34;, &#34;n_paths&#34;, &#34;n_annotations&#34;, &#34;Edit_distance&#34;]
        df = pd.DataFrame(index=df_paths.columns, columns=properties)
        df[&#34;Method&#34;] = [s.method if s.method else None for s in self.experiment.samples.values()]
        df[&#34;Name&#34;] = [s.name if s.name else None for s in self.experiment.samples.values()]
        df[&#34;n_paths&#34;] = df_paths.sum()
        df[&#34;n_annotations&#34;] = {k: df_paths[k][df_paths.index.str.contains(&#34;StructuredAnnotations&#34;)].sum() for k in
                               df_paths.columns}
        df[&#34;og_image_format&#34;] = [s.format if s.format else None for s in self.experiment.samples.values()]
        df[&#34;cost&#34;] = [s.cost if s.cost else None for s in self.experiment.samples.values()]
        df[&#34;attempts&#34;] = [s.attempts if s.attempts else None for s in self.experiment.samples.values()]
        edit_distances = []
        for n in df[&#34;Name&#34;].unique():
            methods = list(df[&#34;Method&#34;].unique())
            for m in methods:
                gt = self.experiment.samples[f&#34;{n}_Bioformats&#34;].metadata_xml
                test = self.experiment.samples[f&#34;{n}_{m}&#34;].metadata_xml
                t0 = time.time()
                #edit_distances.append(self.zss_edit_distance(test, gt))
                edit_distances.append(self.pygram_edit_distance(test, gt))
                t1 = time.time()
        df[&#34;Edit_distance&#34;] = edit_distances

        # save the df to a csv
        df.to_csv(f&#34;{self.out_path}/data_frames/sample_df.csv&#34;)

        return df


    def path_df(
            self,
    ):
        &#34;&#34;&#34;
        TODO: Add docstring
        &#34;&#34;&#34;
        for s in self.experiment.samples.values():
            s.metadata_xml = self.string_to_ome_xml(s.metadata_str)
            s.paths = self.get_paths(s.metadata_xml)
        self.all_paths = pd.Series(list(set(self.flatten([s.paths for s in self.experiment.samples.values()]))))
        df = pd.DataFrame(columns=[f&#34;{s.name}_{s.method}&#34; for s in self.experiment.samples.values()],
                          index=self.all_paths)
        for name, method, path in zip([s.name for s in self.experiment.samples.values()],
                                      [s.method for s in self.experiment.samples.values()],
                                      [s.paths for s in self.experiment.samples.values()]):
            df[f&#34;{name}_{method}&#34;] = df.index.isin(path)

        #save the df to a csv
        df.to_csv(f&#34;{self.out_path}/data_frames/path_df.csv&#34;)
        return df


    def method_edit_distance_plt(
            self,
            df_sample: pd.DataFrame = None,
    ):
        &#34;&#34;&#34;
        This function creates a plot which compares the inter sample standard deviation.
        The X-axis will be the used method, whereas the Y-axis will be the standard deviation.
        &#34;&#34;&#34;
        fig, ax = plt.subplots()
        
        plot = sns.barplot(
            x=df_sample[&#34;Method&#34;],
            y=df_sample[&#34;Edit_distance&#34;],
            edgecolor=&#39;black&#39;,
            ax=ax,
            palette=self.palette0)

        ax.set_xlabel(&#34;Method&#34;, fontsize=14)
        ax.set_ylabel(&#34;Edit Distance&#34;, fontsize=14)
        ax.set_title(&#34;Edit Distance by Method&#34;, fontsize=16)
        ax.tick_params(axis=&#39;x&#39;, rotation=45)

        ax.legend(loc=&#39;upper right&#39;)
        ax.grid(True, which=&#39;both&#39;, linestyle=&#39;--&#39;, linewidth=0.5)
        ax.spines[&#39;top&#39;].set_visible(False)
        ax.spines[&#39;right&#39;].set_visible(False)

        plt.tight_layout()

        plt.savefig(f&#34;{self.out_path}/plots/method_edit_plt.svg&#34;)
        self.plot_dict[&#34;method_edit_plt&#34;] = f&#34;../plots/method_edit_plt.svg&#34;
        #plt.show()

        return fig, ax


    def paths_annotation_stacked_plt(
            self,
            df_sample: pd.DataFrame = None,
            ):
        &#34;&#34;&#34;
        Plots the number of paths and annotations per sample as a stacked bar plot.
        Uses the seaborn library.

        &#34;&#34;&#34;
        fig, ax = plt.subplots()

        n_path_plt = sns.barplot(
            x=df_sample[&#34;Method&#34;],
            y=df_sample[&#34;n_paths&#34;]-df_sample[&#34;n_annotations&#34;],
            edgecolor=&#39;black&#39;,
            ax=ax,
            palette=self.palette0,
            label=&#34;OME Paths&#34;)
        bottom_heights = [patch.get_height() for patch in n_path_plt.patches]
        n_annot_plt = sns.barplot(
            x=df_sample[&#34;Method&#34;],
            y=df_sample[&#34;n_annotations&#34;],
            edgecolor=&#39;black&#39;,
            ax=ax,
            palette=self.palette1,
            label=&#34;Annotation Paths&#34;,
            bottom=bottom_heights)


        ax.set_xlabel(&#34;Sample&#34;, fontsize=14)
        ax.set_ylabel(&#34;Number of Paths&#34;, fontsize=14)
        ax.set_title(&#34;Number of Paths and Annotations per Sample&#34;, fontsize=16)
        ax.tick_params(axis=&#39;x&#39;, rotation=45)

        ax.legend(loc=&#39;upper right&#39;)
        ax.grid(True, which=&#39;both&#39;, linestyle=&#39;--&#39;, linewidth=0.5)
        ax.spines[&#39;top&#39;].set_visible(False)
        ax.spines[&#39;right&#39;].set_visible(False)

        plt.tight_layout()

        plt.savefig(f&#34;{self.out_path}/plots/paths_annotation_stacked_plt.svg&#34;)
        self.plot_dict[&#34;paths_annotation_stacked_plt&#34;] = f&#34;../plots/paths_annotation_stacked_plt.svg&#34;
        #plt.show()

        return fig, ax
    
        
    def n_paths_method_plt(
            self, 
            df_sample: pd.DataFrame = None,
    ):
        &#34;&#34;&#34;
        Plots the number of paths per method as a bar plot.
        
        Parameters:
        - df_sample: pd.DataFrame, a DataFrame containing the data to plot.
        
        Returns:
        - fig: The figure object.
        - ax: The axes object.
        &#34;&#34;&#34;
        fig, ax = plt.subplots()

        plot = sns.barplot(
            x=df_sample[&#34;Method&#34;],
            y=df_sample[&#34;n_paths&#34;],
            edgecolor=&#39;black&#39;,
            ax=ax,
            palette=self.palette0,
            label=&#34;OME Paths&#34;)


        ax.set_xlabel(&#34;Sample&#34;, fontsize=14)
        ax.set_ylabel(&#34;Number of Paths&#34;, fontsize=14)
        ax.set_title(&#34;Number of Paths and Annotations per Sample&#34;, fontsize=16)
        ax.tick_params(axis=&#39;x&#39;, rotation=45)

        ax.legend(loc=&#39;upper right&#39;)
        ax.grid(True, which=&#39;both&#39;, linestyle=&#39;--&#39;, linewidth=0.5)
        ax.spines[&#39;top&#39;].set_visible(False)
        ax.spines[&#39;right&#39;].set_visible(False)

        plt.tight_layout()

        plt.savefig(f&#34;{self.out_path}/plots/paths_stacked_plt.svg&#34;)
        self.plot_dict[&#34;paths_stacked_plt&#34;] = f&#34;../plots/paths_stacked_plt.svg&#34;
        #plt.show()

        return fig, ax


    def format_method_plot(
            self,
            df_sample: pd.DataFrame = None,
    ):
        &#34;&#34;&#34;
        This plot compares the performance of the different methods based on the original image format.
        For each method several bars are plotted, one for each image format.
        &#34;&#34;&#34;
        fig, ax = plt.subplots()

        plot = sns.barplot(
            x=df_sample[&#34;Method&#34;],
            y=df_sample[&#34;Edit_distance&#34;],
            hue=df_sample[&#34;og_image_format&#34;],
            edgecolor=&#39;black&#39;,
            ax=ax,
            palette=self.palette0)


        ax.set_xlabel(&#34;Method&#34;, fontsize=14)
        ax.set_ylabel(&#34;Edit Distance&#34;, fontsize=14)
        ax.set_title(&#34;Edit Distance by Format&#34;, fontsize=16)
        ax.tick_params(axis=&#39;x&#39;, rotation=45)

        ax.legend(loc=&#39;upper right&#39;)
        ax.grid(True, which=&#39;both&#39;, linestyle=&#39;--&#39;, linewidth=0.5)
        ax.spines[&#39;top&#39;].set_visible(False)
        ax.spines[&#39;right&#39;].set_visible(False)

        plt.tight_layout()

        plt.savefig(f&#34;{self.out_path}/plots/paths_stacked_plt.svg&#34;)
        self.plot_dict[&#34;paths_stacked_plt&#34;] = f&#34;../plots/paths_stacked_plt.svg&#34;
        #plt.show()

        return fig, ax
    
    def method_cost_plot(
            self,
            df_sample: pd.DataFrame = None,
    ):
        &#34;&#34;&#34;
        This plot compares the performance of the different methods based on the cost.
        Wont work because OpenAI does not provide the cost of the methods.
        &#34;&#34;&#34;
        pass

    def method_attempts_plot(
            self,
            df_sample: pd.DataFrame = None,
    ):
        &#34;&#34;&#34;
        This plots the number of attempts against the number of paths in the og image.
        &#34;&#34;&#34;
        fig, ax = plt.subplots()


        plot = sns.barplot(
            x=df_sample[&#34;n_paths&#34;],
            y=df_sample[&#34;attempts&#34;],
            edgecolor=&#39;black&#39;,
            hue=df_sample[&#34;Method&#34;],
            ax=ax,
            palette=self.palette0)

        ax.set_xlabel(&#34;Number of Paths&#34;, fontsize=14)
        ax.set_ylabel(&#34;Number of Attempts&#34;, fontsize=14)
        ax.set_title(&#34;Attempts by Paths&#34;, fontsize=16)
        ax.tick_params(axis=&#39;x&#39;, rotation=45)

        ax.legend(loc=&#39;upper right&#39;)
        ax.grid(True, which=&#39;both&#39;, linestyle=&#39;--&#39;, linewidth=0.5)
        ax.spines[&#39;top&#39;].set_visible(False)
        ax.spines[&#39;right&#39;].set_visible(False)

        plt.tight_layout()

        plt.savefig(f&#34;{self.out_path}/plots/attempts_paths_plt.svg&#34;)
        self.plot_dict[&#34;attempts_paths_plt&#34;] = f&#34;../plots/attempts_paths_plt.svg&#34;
        #plt.show()

        return fig, ax
    
    def format_counts_plt(
            self,
            df_sample: pd.DataFrame = None,
    ):
        &#34;&#34;&#34;
        This plot shows the formats on the x axis, and how many samples are in
        each format on the y axis. the different samples need to be identified via
        the name tag to not count the same file multiple times for each method.
        
        &#34;&#34;&#34;
        fig, ax = plt.subplots()
        y = df_sample[df_sample[&#34;Method&#34;]==&#34;Bioformats&#34;][&#34;og_image_format&#34;].value_counts()
        plot = sns.barplot(
            x=y.index,
            y=y,
            edgecolor=&#39;black&#39;,
            ax=ax,
            palette=self.palette0)

        ax.set_xlabel(&#34;Format&#34;, fontsize=14)
        ax.set_ylabel(&#34;Number of Samples&#34;, fontsize=14)
        ax.set_title(&#34;Number of Samples by Format&#34;, fontsize=16)
        ax.tick_params(axis=&#39;x&#39;, rotation=45)
        # set the y ticks to integers
        ax.yaxis.set_major_locator(plt.MaxNLocator(integer=True))

        #ax.legend(loc=&#39;upper right&#39;)
        ax.grid(True, which=&#39;both&#39;, linestyle=&#39;--&#39;, linewidth=0.5)
        ax.spines[&#39;top&#39;].set_visible(False)
        ax.spines[&#39;right&#39;].set_visible(False)

        plt.tight_layout()

        plt.savefig(f&#34;{self.out_path}/plots/format_counts_plt.svg&#34;)
        self.plot_dict[&#34;format_counts_plt&#34;] = f&#34;../plots/format_counts_plt.svg&#34;
        #plt.show()

        return fig, ax
    
    def format_n_paths(
            self,
            df_sample: pd.DataFrame = None,
    ):
        &#34;&#34;&#34;
        This plots shows the format on the x axis and the number of paths of the y axis as a scatter plot for each data point. But only for the Bioformats method.
        &#34;&#34;&#34;
        fig, ax = plt.subplots()

        plot = sns.scatterplot(
            x=df_sample[df_sample[&#34;Method&#34;]==&#34;Bioformats&#34;][&#34;og_image_format&#34;],
            y=df_sample[df_sample[&#34;Method&#34;]==&#34;Bioformats&#34;][&#34;n_paths&#34;],
            edgecolor=&#39;black&#39;,
            ax=ax,
            palette=self.palette0)

        ax.set_xlabel(&#34;Format&#34;, fontsize=14)
        ax.set_ylabel(&#34;Number of Paths&#34;, fontsize=14)
        ax.set_title(&#34;Number of Paths by Format&#34;, fontsize=16)
        ax.tick_params(axis=&#39;x&#39;, rotation=45)
        # set the y ticks to integers
        ax.yaxis.set_major_locator(plt.MaxNLocator(integer=True))

        #ax.legend(loc=&#39;upper right&#39;)
        ax.grid(True, which=&#39;both&#39;, linestyle=&#39;--&#39;, linewidth=0.5)
        ax.spines[&#39;top&#39;].set_visible(False)
        ax.spines[&#39;right&#39;].set_visible(False)

        plt.tight_layout()

        plt.savefig(f&#34;{self.out_path}/plots/format_n_paths_plt.svg&#34;)
        self.plot_dict[&#34;format_n_paths_plt&#34;] = f&#34;../plots/format_n_paths_plt.svg&#34;
        #plt.show()

        return fig, ax
    

    def paths_annotation_stacked_relative_plt(
            self,
            df_sample: pd.DataFrame = None,
            ):
        &#34;&#34;&#34;
        Plots the relative to og_bioformats file number of paths and annotations per sample as a stacked bar plot.
        Uses the seaborn library.

        &#34;&#34;&#34;
        fig, ax = plt.subplots()
        norm_values_n_paths = df_sample[df_sample[&#39;Method&#39;] == &#39;Bioformats&#39;].set_index(&#39;Name&#39;)[&#39;n_paths&#39;]

        n_path_plt = sns.barplot(
            x=df_sample[&#34;Method&#34;],
            y=df_sample.apply(
            lambda row: (row[&#39;n_paths&#39;] / norm_values_n_paths[row[&#39;Name&#39;]]),
            axis=1) * (df_sample[&#34;n_paths&#34;]-df_sample[&#34;n_annotations&#34;])/df_sample[&#34;n_paths&#34;],
            edgecolor=&#39;black&#39;,
            ax=ax,
            label=&#34;OME Paths&#34;,
            palette=self.palette0)

        bottom_heights = [patch.get_height() for patch in n_path_plt.patches]
        print(bottom_heights)
        n_annot_plt = sns.barplot(
            x=df_sample[&#34;Method&#34;],
            y=df_sample.apply(
            lambda row: (row[&#39;n_paths&#39;] / norm_values_n_paths[row[&#39;Name&#39;]]),
            axis=1) * (1-(df_sample[&#34;n_paths&#34;]-df_sample[&#34;n_annotations&#34;])/df_sample[&#34;n_paths&#34;]),
            edgecolor=&#39;black&#39;,
            ax=ax,
            palette=self.palette1,
            label=&#34;Annotation Paths&#34;,
            bottom= bottom_heights,
            )


        ax.set_xlabel(&#34;Sample&#34;, fontsize=14)
        ax.set_ylabel(&#34;Number of Paths&#34;, fontsize=14)
        ax.set_title(&#34;Number of Paths and Annotations per Sample&#34;, fontsize=16)
        ax.tick_params(axis=&#39;x&#39;, rotation=45)

        ax.legend(loc=&#39;upper right&#39;)
        ax.grid(True, which=&#39;both&#39;, linestyle=&#39;--&#39;, linewidth=0.5)
        ax.spines[&#39;top&#39;].set_visible(False)
        ax.spines[&#39;right&#39;].set_visible(False)

        plt.tight_layout()

        plt.savefig(f&#34;{self.out_path}/plots/paths_annotation_stacked_relative_plt.svg&#34;)
        self.plot_dict[&#34;paths_annotation_stacked_relative_plt&#34;] = f&#34;../plots/paths_annotation_stacked_relative_plt.svg&#34;
        #plt.show()

        return fig, ax
    
    def attempts_paths_plt(
            self,
            df_sample: pd.DataFrame = None,
    ):
        &#34;&#34;&#34;
        This plot shows the number of attempts per number of paths(of the original bioformats file). Each Method is its own line.
        &#34;&#34;&#34;
        fig, ax = plt.subplots()

        plot = sns.lineplot(
            x=df_sample[&#34;n_paths&#34;],
            y=df_sample[&#34;attempts&#34;],
            hue=df_sample[&#34;Method&#34;],
            ax=ax,
            palette=self.palette0)
        
        ax.set_xlabel(&#34;Number of Paths&#34;, fontsize=14)
        ax.set_ylabel(&#34;Number of Attempts&#34;, fontsize=14)
        ax.set_title(&#34;Attempts by Paths&#34;, fontsize=16)
        ax.tick_params(axis=&#39;x&#39;, rotation=45)

        ax.legend(loc=&#39;upper right&#39;)
        ax.grid(True, which=&#39;both&#39;, linestyle=&#39;--&#39;, linewidth=0.5)
        ax.spines[&#39;top&#39;].set_visible(False)
        ax.spines[&#39;right&#39;].set_visible(False)

        plt.tight_layout()

        plt.savefig(f&#34;{self.out_path}/plots/attempts_paths_plt.svg&#34;)
        self.plot_dict[&#34;attempts_paths_plt&#34;] = f&#34;../plots/attempts_paths_plt.svg&#34;
        #plt.show()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="src.metagpt.OME_evaluator.OMEEvaluator.align_paths"><code class="name flex">
<span>def <span class="ident">align_paths</span></span>(<span>self, paths_a, paths_b)</span>
</code></dt>
<dd>
<div class="desc"><p>Align the paths such that the sum of distances between the paths is minimized.
paths_a: set of paths
paths_b: set of paths
:return: list of tuples of aligned paths</p></div>
</dd>
<dt id="src.metagpt.OME_evaluator.OMEEvaluator.align_sequences"><code class="name flex">
<span>def <span class="ident">align_sequences</span></span>(<span>self, s1, s2, cost=&lt;function OMEEvaluator.&lt;lambda&gt;&gt;)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.metagpt.OME_evaluator.OMEEvaluator.align_sequences_score"><code class="name flex">
<span>def <span class="ident">align_sequences_score</span></span>(<span>self, s1, s2, cost=&lt;function OMEEvaluator.&lt;lambda&gt;&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>returns only the score for the alignment
:param s1:
:param s2:
:param cost:
:return:</p></div>
</dd>
<dt id="src.metagpt.OME_evaluator.OMEEvaluator.attempts_paths_plt"><code class="name flex">
<span>def <span class="ident">attempts_paths_plt</span></span>(<span>self, df_sample: pandas.core.frame.DataFrame = None)</span>
</code></dt>
<dd>
<div class="desc"><p>This plot shows the number of attempts per number of paths(of the original bioformats file). Each Method is its own line.</p></div>
</dd>
<dt id="src.metagpt.OME_evaluator.OMEEvaluator.element_to_pygram"><code class="name flex">
<span>def <span class="ident">element_to_pygram</span></span>(<span>self, element: xml.etree.ElementTree.Element)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert an xml element to a pygram tree.</p></div>
</dd>
<dt id="src.metagpt.OME_evaluator.OMEEvaluator.flatten"><code class="name flex">
<span>def <span class="ident">flatten</span></span>(<span>self, container)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.metagpt.OME_evaluator.OMEEvaluator.format_counts_plt"><code class="name flex">
<span>def <span class="ident">format_counts_plt</span></span>(<span>self, df_sample: pandas.core.frame.DataFrame = None)</span>
</code></dt>
<dd>
<div class="desc"><p>This plot shows the formats on the x axis, and how many samples are in
each format on the y axis. the different samples need to be identified via
the name tag to not count the same file multiple times for each method.</p></div>
</dd>
<dt id="src.metagpt.OME_evaluator.OMEEvaluator.format_method_plot"><code class="name flex">
<span>def <span class="ident">format_method_plot</span></span>(<span>self, df_sample: pandas.core.frame.DataFrame = None)</span>
</code></dt>
<dd>
<div class="desc"><p>This plot compares the performance of the different methods based on the original image format.
For each method several bars are plotted, one for each image format.</p></div>
</dd>
<dt id="src.metagpt.OME_evaluator.OMEEvaluator.format_n_paths"><code class="name flex">
<span>def <span class="ident">format_n_paths</span></span>(<span>self, df_sample: pandas.core.frame.DataFrame = None)</span>
</code></dt>
<dd>
<div class="desc"><p>This plots shows the format on the x axis and the number of paths of the y axis as a scatter plot for each data point. But only for the Bioformats method.</p></div>
</dd>
<dt id="src.metagpt.OME_evaluator.OMEEvaluator.get_graph"><code class="name flex">
<span>def <span class="ident">get_graph</span></span>(<span>self, xml_root: xml.etree.ElementTree.Element, root=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to get the graph representation of an XML tree.</p></div>
</dd>
<dt id="src.metagpt.OME_evaluator.OMEEvaluator.get_paths"><code class="name flex">
<span>def <span class="ident">get_paths</span></span>(<span>self, xml_root: xml.etree.ElementTree.Element, path: str = '') ‑> set</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to get all paths in an XML tree.
:return: set of paths</p></div>
</dd>
<dt id="src.metagpt.OME_evaluator.OMEEvaluator.method_attempts_plot"><code class="name flex">
<span>def <span class="ident">method_attempts_plot</span></span>(<span>self, df_sample: pandas.core.frame.DataFrame = None)</span>
</code></dt>
<dd>
<div class="desc"><p>This plots the number of attempts against the number of paths in the og image.</p></div>
</dd>
<dt id="src.metagpt.OME_evaluator.OMEEvaluator.method_cost_plot"><code class="name flex">
<span>def <span class="ident">method_cost_plot</span></span>(<span>self, df_sample: pandas.core.frame.DataFrame = None)</span>
</code></dt>
<dd>
<div class="desc"><p>This plot compares the performance of the different methods based on the cost.
Wont work because OpenAI does not provide the cost of the methods.</p></div>
</dd>
<dt id="src.metagpt.OME_evaluator.OMEEvaluator.method_edit_distance_plt"><code class="name flex">
<span>def <span class="ident">method_edit_distance_plt</span></span>(<span>self, df_sample: pandas.core.frame.DataFrame = None)</span>
</code></dt>
<dd>
<div class="desc"><p>This function creates a plot which compares the inter sample standard deviation.
The X-axis will be the used method, whereas the Y-axis will be the standard deviation.</p></div>
</dd>
<dt id="src.metagpt.OME_evaluator.OMEEvaluator.n_paths_method_plt"><code class="name flex">
<span>def <span class="ident">n_paths_method_plt</span></span>(<span>self, df_sample: pandas.core.frame.DataFrame = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the number of paths per method as a bar plot.</p>
<p>Parameters:
- df_sample: pd.DataFrame, a DataFrame containing the data to plot.</p>
<p>Returns:
- fig: The figure object.
- ax: The axes object.</p></div>
</dd>
<dt id="src.metagpt.OME_evaluator.OMEEvaluator.path_df"><code class="name flex">
<span>def <span class="ident">path_df</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO: Add docstring</p></div>
</dd>
<dt id="src.metagpt.OME_evaluator.OMEEvaluator.path_difference"><code class="name flex">
<span>def <span class="ident">path_difference</span></span>(<span>self, xml_a: xml.etree.ElementTree.Element, xml_b: xml.etree.ElementTree.Element)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the length of the difference between the path sets in two xml trees.</p></div>
</dd>
<dt id="src.metagpt.OME_evaluator.OMEEvaluator.paths_annotation_stacked_plt"><code class="name flex">
<span>def <span class="ident">paths_annotation_stacked_plt</span></span>(<span>self, df_sample: pandas.core.frame.DataFrame = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the number of paths and annotations per sample as a stacked bar plot.
Uses the seaborn library.</p></div>
</dd>
<dt id="src.metagpt.OME_evaluator.OMEEvaluator.paths_annotation_stacked_relative_plt"><code class="name flex">
<span>def <span class="ident">paths_annotation_stacked_relative_plt</span></span>(<span>self, df_sample: pandas.core.frame.DataFrame = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the relative to og_bioformats file number of paths and annotations per sample as a stacked bar plot.
Uses the seaborn library.</p></div>
</dd>
<dt id="src.metagpt.OME_evaluator.OMEEvaluator.pygram_edit_distance"><code class="name flex">
<span>def <span class="ident">pygram_edit_distance</span></span>(<span>self, xml_a: xml.etree.ElementTree.Element, xml_b: xml.etree.ElementTree.Element)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the edit distance between two xml trees on word level.
Here an outline of the algorithm:</p></div>
</dd>
<dt id="src.metagpt.OME_evaluator.OMEEvaluator.read_ome_xml"><code class="name flex">
<span>def <span class="ident">read_ome_xml</span></span>(<span>self, path: str)</span>
</code></dt>
<dd>
<div class="desc"><p>This method reads the ome xml file and returns the root element.</p></div>
</dd>
<dt id="src.metagpt.OME_evaluator.OMEEvaluator.report"><code class="name flex">
<span>def <span class="ident">report</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Write evaluation report to file.</p></div>
</dd>
<dt id="src.metagpt.OME_evaluator.OMEEvaluator.sample_df"><code class="name flex">
<span>def <span class="ident">sample_df</span></span>(<span>self, df_paths: pandas.core.frame.DataFrame = None)</span>
</code></dt>
<dd>
<div class="desc"><p>This function creates a df with samples as Index and properties as Columns.
TODO: Add docstring</p></div>
</dd>
<dt id="src.metagpt.OME_evaluator.OMEEvaluator.string_to_ome_xml"><code class="name flex">
<span>def <span class="ident">string_to_ome_xml</span></span>(<span>self, string)</span>
</code></dt>
<dd>
<div class="desc"><p>This method reads the ome xml string and returns the root element.</p></div>
</dd>
<dt id="src.metagpt.OME_evaluator.OMEEvaluator.word_edit_distance"><code class="name flex">
<span>def <span class="ident">word_edit_distance</span></span>(<span>self, aligned_paths) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the word level edit distance between two sets of paths.
aligned_paths: list of tuples of aligned paths</p></div>
</dd>
<dt id="src.metagpt.OME_evaluator.OMEEvaluator.zss_edit_distance"><code class="name flex">
<span>def <span class="ident">zss_edit_distance</span></span>(<span>self, xml_a: xml.etree.ElementTree.Element, xml_b: xml.etree.ElementTree.Element)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the edit distance between two xml trees on word level.
Here an outline of the algorithm:
1. Get the paths of the xml trees.
2. Align the paths such that the distance between the paths is minimized.
3. Calculate the word level edit distance between the paths.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.metagpt" href="index.html">src.metagpt</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.metagpt.OME_evaluator.OMEEvaluator" href="#src.metagpt.OME_evaluator.OMEEvaluator">OMEEvaluator</a></code></h4>
<ul class="">
<li><code><a title="src.metagpt.OME_evaluator.OMEEvaluator.align_paths" href="#src.metagpt.OME_evaluator.OMEEvaluator.align_paths">align_paths</a></code></li>
<li><code><a title="src.metagpt.OME_evaluator.OMEEvaluator.align_sequences" href="#src.metagpt.OME_evaluator.OMEEvaluator.align_sequences">align_sequences</a></code></li>
<li><code><a title="src.metagpt.OME_evaluator.OMEEvaluator.align_sequences_score" href="#src.metagpt.OME_evaluator.OMEEvaluator.align_sequences_score">align_sequences_score</a></code></li>
<li><code><a title="src.metagpt.OME_evaluator.OMEEvaluator.attempts_paths_plt" href="#src.metagpt.OME_evaluator.OMEEvaluator.attempts_paths_plt">attempts_paths_plt</a></code></li>
<li><code><a title="src.metagpt.OME_evaluator.OMEEvaluator.element_to_pygram" href="#src.metagpt.OME_evaluator.OMEEvaluator.element_to_pygram">element_to_pygram</a></code></li>
<li><code><a title="src.metagpt.OME_evaluator.OMEEvaluator.flatten" href="#src.metagpt.OME_evaluator.OMEEvaluator.flatten">flatten</a></code></li>
<li><code><a title="src.metagpt.OME_evaluator.OMEEvaluator.format_counts_plt" href="#src.metagpt.OME_evaluator.OMEEvaluator.format_counts_plt">format_counts_plt</a></code></li>
<li><code><a title="src.metagpt.OME_evaluator.OMEEvaluator.format_method_plot" href="#src.metagpt.OME_evaluator.OMEEvaluator.format_method_plot">format_method_plot</a></code></li>
<li><code><a title="src.metagpt.OME_evaluator.OMEEvaluator.format_n_paths" href="#src.metagpt.OME_evaluator.OMEEvaluator.format_n_paths">format_n_paths</a></code></li>
<li><code><a title="src.metagpt.OME_evaluator.OMEEvaluator.get_graph" href="#src.metagpt.OME_evaluator.OMEEvaluator.get_graph">get_graph</a></code></li>
<li><code><a title="src.metagpt.OME_evaluator.OMEEvaluator.get_paths" href="#src.metagpt.OME_evaluator.OMEEvaluator.get_paths">get_paths</a></code></li>
<li><code><a title="src.metagpt.OME_evaluator.OMEEvaluator.method_attempts_plot" href="#src.metagpt.OME_evaluator.OMEEvaluator.method_attempts_plot">method_attempts_plot</a></code></li>
<li><code><a title="src.metagpt.OME_evaluator.OMEEvaluator.method_cost_plot" href="#src.metagpt.OME_evaluator.OMEEvaluator.method_cost_plot">method_cost_plot</a></code></li>
<li><code><a title="src.metagpt.OME_evaluator.OMEEvaluator.method_edit_distance_plt" href="#src.metagpt.OME_evaluator.OMEEvaluator.method_edit_distance_plt">method_edit_distance_plt</a></code></li>
<li><code><a title="src.metagpt.OME_evaluator.OMEEvaluator.n_paths_method_plt" href="#src.metagpt.OME_evaluator.OMEEvaluator.n_paths_method_plt">n_paths_method_plt</a></code></li>
<li><code><a title="src.metagpt.OME_evaluator.OMEEvaluator.path_df" href="#src.metagpt.OME_evaluator.OMEEvaluator.path_df">path_df</a></code></li>
<li><code><a title="src.metagpt.OME_evaluator.OMEEvaluator.path_difference" href="#src.metagpt.OME_evaluator.OMEEvaluator.path_difference">path_difference</a></code></li>
<li><code><a title="src.metagpt.OME_evaluator.OMEEvaluator.paths_annotation_stacked_plt" href="#src.metagpt.OME_evaluator.OMEEvaluator.paths_annotation_stacked_plt">paths_annotation_stacked_plt</a></code></li>
<li><code><a title="src.metagpt.OME_evaluator.OMEEvaluator.paths_annotation_stacked_relative_plt" href="#src.metagpt.OME_evaluator.OMEEvaluator.paths_annotation_stacked_relative_plt">paths_annotation_stacked_relative_plt</a></code></li>
<li><code><a title="src.metagpt.OME_evaluator.OMEEvaluator.pygram_edit_distance" href="#src.metagpt.OME_evaluator.OMEEvaluator.pygram_edit_distance">pygram_edit_distance</a></code></li>
<li><code><a title="src.metagpt.OME_evaluator.OMEEvaluator.read_ome_xml" href="#src.metagpt.OME_evaluator.OMEEvaluator.read_ome_xml">read_ome_xml</a></code></li>
<li><code><a title="src.metagpt.OME_evaluator.OMEEvaluator.report" href="#src.metagpt.OME_evaluator.OMEEvaluator.report">report</a></code></li>
<li><code><a title="src.metagpt.OME_evaluator.OMEEvaluator.sample_df" href="#src.metagpt.OME_evaluator.OMEEvaluator.sample_df">sample_df</a></code></li>
<li><code><a title="src.metagpt.OME_evaluator.OMEEvaluator.string_to_ome_xml" href="#src.metagpt.OME_evaluator.OMEEvaluator.string_to_ome_xml">string_to_ome_xml</a></code></li>
<li><code><a title="src.metagpt.OME_evaluator.OMEEvaluator.word_edit_distance" href="#src.metagpt.OME_evaluator.OMEEvaluator.word_edit_distance">word_edit_distance</a></code></li>
<li><code><a title="src.metagpt.OME_evaluator.OMEEvaluator.zss_edit_distance" href="#src.metagpt.OME_evaluator.OMEEvaluator.zss_edit_distance">zss_edit_distance</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
